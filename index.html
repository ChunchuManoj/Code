<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Java Program</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            margin: 20px;
        }
    </style>
</head>
<body>

<pre>
<code>
SINGLE SOURCE SHORTEST PATH PROBLEM

AIM:
Write a java program to implement Dijkstra’s algorithm for the Single source shortest path problem.

DESCRIPTION:
Single-Source Shortest Paths – Dijkstra's Algorithm. Given a source vertex s from set of vertices V in a weighted graph where all its edge weights w(u, v) are non-negative, find the shortest-path weights d(s, v) from given source s for all vertices v present in the graph.

PROGRAM:
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Iterator; import java.util.Scanner; import java.util.Set;

public class DijkstraAlgorithmSet
{
private int distances[];
private Set<Integer> settled; private Set<Integer> unsettled; private int number_of_nodes; private int adjacencyMatrix[][];

public DijkstraAlgorithmSet(int number_of_nodes)
{
this.number_of_nodes = number_of_nodes; distances = new int[number_of_nodes + 1]; settled = new HashSet<Integer>(); unsettled = new HashSet<Integer>();
adjacencyMatrix = new int[number_of_nodes + 1][number_of_nodes + 1];
}

public void dijkstra_algorithm(int adjacency_matrix[][], int source)
{
int evaluationNode;
for (int i = 1; i <= number_of_nodes; i++)
for (int j = 1; j <= number_of_nodes; j++) adjacencyMatrix[i][j] = adjacency_matrix[i][j];

for (int i = 1; i <= number_of_nodes; i++)
{
distances[i] = Integer.MAX_VALUE;
}
 
unsettled.add(source); distances[source] = 0;
while (!unsettled.isEmpty())
{
evaluationNode = getNodeWithMinimumDistanceFromUnsettled();

unsettled.remove(evaluationNode); settled.add(evaluationNode); evaluateNeighbours(evaluationNode);
}
}

private int getNodeWithMinimumDistanceFromUnsettled()
{
int min ;
int node = 0;

Iterator<Integer> iterator = unsettled.iterator(); node = iterator.next();
min = distances[node];
for (int i = 1; i <= distances.length; i++)
{
if (unsettled.contains(i))
{
if (distances[i] <= min)
{
min = distances[i]; node = i;
}
}
}
return node;
}

private void evaluateNeighbours(int evaluationNode)
{
int edgeDistance = -1;
int newDistance = -1;

for (int destinationNode = 1; destinationNode <= number_of_nodes; destinationNode++)
{
if (!settled.contains(destinationNode))
{
if (adjacencyMatrix[evaluationNode][destinationNode] != Integer.MAX_VALUE)
 
{
edgeDistance = adjacencyMatrix[evaluationNode][destinationNode]; newDistance = distances[evaluationNode] + edgeDistance;
if (newDistance < distances[destinationNode])
{
distances[destinationNode] = newDistance;
}
unsettled.add(destinationNode);
}
}
}
}

public static void main(String... arg)
{
int adjacency_matrix[][]; int number_of_vertices; int source = 0;
Scanner scan = new Scanner(System.in);
try
{
System.out.println("Enter the number of vertices"); number_of_vertices = scan.nextInt();
adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];

System.out.println("Enter the Weighted Matrix for the graph");
for (int i = 1; i <= number_of_vertices; i++)
{
for (int j = 1; j <= number_of_vertices; j++)
{
adjacency_matrix[i][j] = scan.nextInt();
if (i == j)
{
adjacency_matrix[i][j] = 0;
continue;
}
if (adjacency_matrix[i][j] == 0)
{
adjacency_matrix[i][j] = Integer.MAX_VALUE;
}
}
}

System.out.println("Enter the source "); source = scan.nextInt();
 
DijkstraAlgorithmSet dijkstrasAlgorithm = new DijkstraAlgorithmSet(number_of_vertices); dijkstrasAlgorithm.dijkstra_algorithm(adjacency_matrix, source);

System.out.println("The Shorted Path to all nodes are ");
for (int i = 1; i <= dijkstrasAlgorithm.distances.length - 1; i++)
{
System.out.println(source + " to " + i + " is "+ dijkstrasAlgorithm.distances[i]);
}
} catch (InputMismatchException inputMismatch)
{
System.out.println("Wrong Input Format");
}
scan.close();
}
}
OUTPUT:
$ javac DijkstraAlgorithmSet.java
$ java DijkstraAlgorithmSet Enter the number of vertices
5
Enter the Weighted Matrix for the graph 0 9 6 5 3
0 0 0 0 0
0 2 0 4 0
0 0 0 0 0
0 0 0 0 0
Enter the source
1
The Shorted Path to all nodes are 1 to 1 is 0
1 to 2 is 8
1 to 3 is 6
1 to 4 is 5
1 to 5 is 3
EXPERIMENT :  OPTIMAL BINARY SEARCH TREE PROBLEM

AIM:
Write a java program to implement Dynamic Programming algorithm for the Optimal Binary Search Tree Problem.

DESCRIPTION:
optimal binary search tree (Optimal BST), sometimes called a weight-balanced binary tree,[1] is a binary search tree which provides the smallest possible search time (or expected search time) for a given sequence of accesses (or access probabilities). Optimal BSTs are generally divided into two types: static and dynamic.
In the static optimality problem, the tree cannot be modified after it has been constructed. In this case, there exists some particular layout of the nodes of the tree which provides the smallest expected search time for the given access probabilities. Various algorithms exist to construct or approximate the statically optimal tree given the information on the access probabilities of the elements.

PROGRAM:
import java.io.*; import java.util.*; class Optimal
{
public int p[]; public int q[]; public int a[]; public int w[][];
public int c[][];
public int r[][]; public int n;
int front,rear,queue[]; public Optimal(int SIZE)
{
p=new int[SIZE]; q= new int[SIZE]; a=new int[SIZE];
w=new int[SIZE][SIZE]; c=new int[SIZE][SIZE]; r=new int[SIZE][SIZE]; queue=new int[SIZE]; front=rear=-1;
}
/* This function returns a value in the range r[i][j-1] to r[i+1][j] SO that the cost c[i][k-1] + c[k][j] is minimum */

public int Min_Value(int i, int j)
{
int m,k=0;
 
int minimum = 32000;
for (m=r[i][j-1] ; m<=r[i+1][j] ; m++)
{
if ((c[i][m-1]+c[m][j]) < minimum)
{
minimum = c[i][m-1] + c[m][j]; k = m;
}
}
return k;
}
/* This function builds the table from all the given probabilities It basically computes C,r,W values */

public void OBST()
{
int i, j, k, l, m;
for (i=0 ; i<n ; i++)
{
// Initialize w[i][i] = q[i];
r[i][i] = c[i][i] = 0;
// Optimal trees with one node w[i][i+1] = q[i] + q[i+1] + p[i+1]; r[i][i+1] = i+1;
c[i][i+1] = q[i] + q[i+1] + p[i+1];
}
w[n][n] = q[n];
r[n][n] = c[n][n] = 0;
// Find optimal trees with m nodes for (m=2 ; m<=n ; m++)
{
for (i=0 ; i<=n-m ; i++)
{
j = i+m;
w[i][j] = w[i][j-1] + p[j] + q[j]; k = Min_Value(i,j);
c[i][j] = w[i][j] + c[i][k-1] + c[k][j]; r[i][j] = k;
}
}
}

/*This function builds the tree from the tables made by the OBST function */ public void build_tree()
 
{
int i, j, k;
System.out.print("The Optimal Binary Search Tree For The Given Nodes Is	\n");
System.out.print("\n The Root of this OBST is :: "+r[0][n]); System.out.print("\n The Cost Of this OBST is :: "+c[0][n]); System.out.print("\n\n\tNODE\tLEFT CHILD\tRIGHT CHILD"); System.out.println("\n	"); queue[++rear] = 0;
queue[++rear] = n; while(front != rear)
{
i = queue[++front]; j = queue[++front]; k = r[i][j];
System.out.print("\n	"+k); if (r[i][k-1] != 0)
{
System.out.print("	"+r[i][k-1]); queue[++rear] = i;
queue[++rear] = k-1;
}
else
System.out.print("	-");
if(r[k][j] != 0)
{
System.out.print("	"+r[k][j]); queue[++rear] = k;
queue[++rear] = j;
}
else
System.out.print("	-");
}
System.out.println("\n");
}
}
/* This is the main function */ class OBSTDemo
{
public static void main (String[] args )throws IOException,NullPointerException
{
Optimal obj=new Optimal(10); int i;
System.out.print("\n Optimal Binary Search Tree \n"); System.out.print("\n Enter the number of nodes "); obj.n=getInt();
 
System.out.print("\n Enter the data as	\n");
for (i=1;i<=obj.n;i++)
{
System.out.print("\n a["+i+"]"); obj.a[i]=getInt();
}
for (i=1 ; i<=obj.n ; i++)
{
System.out.println("p["+i+"]"); obj.p[i]=getInt();
}
for (i=0 ; i<=obj.n ; i++)
{
System.out.print("q["+i+"]"); obj.q[i]=getInt();
}
obj.OBST();
obj.build_tree();
}

public static String getString() throws IOException
{
InputStreamReader input = new InputStreamReader(System.in); BufferedReader b = new BufferedReader(input);
String str = b.readLine();//reading the string from console return str;
}

public static char getChar() throws IOException
{
String str = getString();
return str.charAt(0);//reading first char of console string
}
public static int getInt() throws IOException
{
String str = getString();
return Integer.parseInt(str);//converting console string to numeric value
}
}
 
OUTPUT:
Optimal Binary Search Tree Enter the number of nodes 4 Enter the data as ....


a[1] 1
a[2] 2
a[3] 3
a[4] 4


p[1] 3
p[2] 3
p[3] 1
p[4] 1


q[0] 2
q[1] 3
q[2] 1
q[3] 1
q[4] 1


The Optimal Binary Search Tree For The Given Nodes Is ....

The Root of this OBST is :: 2 The Cost Of this OBST is :: 32


NODE	LEFT CHILD	RIGHT CHILD




2	1	3
1	-	-
3	-	4
4	-	-

 Write a java program that implements Prim’s algorithm to generate minimum cost spanning tree.
Source Code :
import java.util.InputMismatchException;
import java.util.Scanner;
public class Prims
{
private boolean unsettled[]; private boolean settled[]; private int numberofvertices; private int adjacencyMatrix[][]; private int key[];
public static final int INFINITE = 999;
private int parent[];
public Prims(int numberofvertices)
{
this.numberofvertices = numberofvertices; unsettled = new boolean[numberofvertices + 1]; settled = new boolean[numberofvertices + 1];
adjacencyMatrix = new int[numberofvertices + 1][numberofvertices + 1]; key = new int[numberofvertices + 1];
parent = new int[numberofvertices + 1];
}

public int getUnsettledCount(boolean unsettled[])
{
int count = 0;
for (int index = 0; index < unsettled.length; index++)
{
if (unsettled[index])
{
count++;
}
}
return count;
}

public void primsAlgorithm(int adjacencyMatrix[][])
{
int evaluationVertex;
for (int source = 1; source <= numberofvertices; source++)
{
for (int destination = 1; destination <= numberofvertices; destination++)
{
this.adjacencyMatrix[source][destination] = adjacencyMatrix[source][destination];
}
}

for (int index = 1; index <= numberofvertices; index++)
{
key[index] = INFINITE;
}
key[1] = 0; unsettled[1] = true; parent[1] = 1;

while (getUnsettledCount(unsettled) != 0)
{
evaluationVertex = getMimumKeyVertexFromUnsettled(unsettled); unsettled[evaluationVertex] = false;
settled[evaluationVertex] = true; evaluateNeighbours(evaluationVertex);
}
}
private int getMimumKeyVertexFromUnsettled(boolean[] unsettled2)
{
int min = Integer.MAX_VALUE;
int node = 0;
for (int vertex = 1; vertex <= numberofvertices; vertex++)
{
if (unsettled[vertex] == true && key[vertex] < min)
{
node = vertex; min = key[vertex];
}
}
return node;
}

public void evaluateNeighbours(int evaluationVertex)
{

for (int destinationvertex = 1; destinationvertex <= numberofvertices; destinationvertex++)
{
if (settled[destinationvertex] == false)
{
if (adjacencyMatrix[evaluationVertex][destinationvertex] != INFINITE)
{
if (adjacencyMatrix[evaluationVertex][destinationvertex] < key[destinationvertex])
{
key[destinationvertex] = adjacencyMatrix[evaluationVertex][destinationvertex]; parent[destinationvertex] = evaluationVertex;
}
unsettled[destinationvertex] = true;
}
}
}
}
public void printMST()
{
System.out.println("SOURCE : DESTINATION = WEIGHT");
for (int vertex = 2; vertex <= numberofvertices; vertex++)
{
System.out.println(parent[vertex]	+	"\t:\t"	+	vertex	+"\t=\t"+ adjacencyMatrix[parent[vertex]][vertex]);
}
}
public static void main(String... arg)
{
int adjacency_matrix[][];
int number_of_vertices;
Scanner scan = new Scanner(System.in);
try
{
System.out.println("Enter the number of vertices"); number_of_vertices = scan.nextInt();
adjacency_matrix = new int[number_of_vertices + 1][number_of_vertices + 1];

System.out.println("Enter the Weighted Matrix for the graph");
for (int i = 1; i <= number_of_vertices; i++)
{
for (int j = 1; j <= number_of_vertices; j++)
{
adjacency_matrix[i][j] = scan.nextInt();

if (i == j)
{
adjacency_matrix[i][j] = 0;
continue;
}
if (adjacency_matrix[i][j] == 0)
{
adjacency_matrix[i][j] = INFINITE;
}
}
}
Prims prims = new Prims(number_of_vertices); prims.primsAlgorithm(adjacency_matrix); prims.printMST();

} catch (InputMismatchException inputMismatch)
{
System.out.println("Wrong Input Format");
}
scan.close();
}
}


Output:
$javac Prims.java
$java Prims

Enter the number of vertices 5
Enter the Weighted Matrix for the graph 0 4 0 0 5
4 0 3 6 1
0 3 0 6 2
0 6 6 0 7
5 1 2 7 0


SOURCE : DESTINATION =	WEIGHT
1	:	2	=	4
5	:	3	=	2
2	:	4	=	6
2	:	5	=	1














11. Write a java program that implements Kruskal’s algorithm to generate minimum cost spanning tree.
Source Code :
// Java program for Kruskal's algorithm to find Minimum
// Spanning Tree of a given connected, undirected and
// weighted graph import java.util.*; import java.lang.*; import java.io.*;

class Graph
{
// A class to represent a graph edge
class Edge implements Comparable<Edge>
{
int src, dest, weight;

// Comparator function used for sorting edges
// based on their weight
public int compareTo(Edge compareEdge)
{
return this.weight-compareEdge.weight;
}
};

// A class to represent a subset for union-find class subset
{
int parent, rank;
};

int V, E;	// V-> no. of vertices & E->no.of edges Edge edge[]; // collection of all edges

// Creates a graph with V vertices and E edges

Graph(int v, int e)
{
V = v; E = e;
edge = new Edge[E]; for (int i=0; i<e; ++i)
edge[i] = new Edge();
}

// A utility function to find set of an element i
// (uses path compression technique) int find(subset subsets[], int i)
{
// find root and make root as parent of i (path compression) if (subsets[i].parent != i)
subsets[i].parent = find(subsets, subsets[i].parent);

return subsets[i].parent;
}

// A function that does union of two sets of x and y
// (uses union by rank)
void Union(subset subsets[], int x, int y)
{
int xroot = find(subsets, x); int yroot = find(subsets, y);

// Attach smaller rank tree under root of high rank tree
// (Union by Rank)
if (subsets[xroot].rank < subsets[yroot].rank) subsets[xroot].parent = yroot;
else if (subsets[xroot].rank > subsets[yroot].rank) subsets[yroot].parent = xroot;

// If ranks are same, then make one as root and increment
// its rank by one else
{
subsets[yroot].parent = xroot; subsets[xroot].rank++;
}
}

// The main function to construct MST using Kruskal's algorithm void KruskalMST()
{
Edge result[] = new Edge[V]; // Tnis will store the resultant MST int e = 0; // An index variable, used for result[]
int i = 0; // An index variable, used for sorted edges for (i=0; i<V; ++i)
result[i] = new Edge();

// Step 1: Sort all the edges in non-decreasing order of their
// weight. If we are not allowed to change the given graph, we
// can create a copy of array of edges Arrays.sort(edge);

// Allocate memory for creating V ssubsets subset subsets[] = new subset[V];
for(i=0; i<V; ++i) subsets[i]=new subset();

// Create V subsets with single elements for (int v = 0; v < V; ++v)
{
subsets[v].parent = v; subsets[v].rank = 0;
}

i = 0; // Index used to pick next edge

// Number of edges to be taken is equal to V-1 while (e < V - 1)
{
// Step 2: Pick the smallest edge. And increment
// the index for next iteration Edge next_edge = new Edge(); next_edge = edge[i++];

int x = find(subsets, next_edge.src); int y = find(subsets, next_edge.dest);

// If including this edge does't cause cycle,
// include it in result and increment the index
// of result for next edge if (x != y)
{
result[e++] = next_edge; Union(subsets, x, y);
}
// Else discard the next_edge
}

// print the contents of result[] to display
// the built MST
System.out.println("Following are the edges in " +
"the constructed MST"); for (i = 0; i < e; ++i)
System.out.println(result[i].src+" -- " + result[i].dest+" == " + result[i].weight);
}

// Driver Program
public static void main (String[] args)
{

/* Let us create following weighted graph 10
0	1
| \	|
6| 5\ |15
|	\ |
2	3
4	*/
int V = 4; // Number of vertices in graph int E = 5; // Number of edges in graph Graph graph = new Graph(V, E);

// add edge 0-1 graph.edge[0].src = 0;
graph.edge[0].dest = 1;
graph.edge[0].weight = 10;

// add edge 0-2 graph.edge[1].src = 0;
graph.edge[1].dest = 2;
graph.edge[1].weight = 6;

// add edge 0-3 graph.edge[2].src = 0;
graph.edge[2].dest = 3;
graph.edge[2].weight = 5;

// add edge 1-3 graph.edge[3].src = 1;
graph.edge[3].dest = 3;
graph.edge[3].weight = 15;

// add edge 2-3 graph.edge[4].src = 2;
graph.edge[4].dest = 3;
graph.edge[4].weight = 4;

graph.KruskalMST();
}
}

 
Output:
 

Following are the edges in the constructed MST 2 -- 3 == 4
0 -- 3 == 5
0 -- 1 == 10
 
12. Write a java program to implement Floyd’s Algorithm for all pairs shortest path problem.
Source Code :
import java.util.PriorityQueue; import java.util.List;
import java.util.ArrayList; import java.util.Collections;

class Vertex implements Comparable<Vertex>
{
public final String name; public Edge[] adjacencies;
public double minDistance = Double.POSITIVE_INFINITY; public Vertex previous;
public Vertex(String argName) { name = argName; } public String toString() { return name; }
public int compareTo(Vertex other)
{
return Double.compare(minDistance, other.minDistance);
}

}

class Edge
{
public final Vertex target; public final double weight;
public Edge(Vertex argTarget, double argWeight)
{ target = argTarget; weight = argWeight; }
}

public class Dijkstra
{
public static void computePaths(Vertex source)
{
source.minDistance = 0.;
PriorityQueue<Vertex> vertexQueue = new PriorityQueue<Vertex>(); vertexQueue.add(source);

while (!vertexQueue.isEmpty()) { Vertex u = vertexQueue.poll();

// Visit each edge exiting u for (Edge e : u.adjacencies)
{
Vertex v = e.target; double weight = e.weight;
double distanceThroughU = u.minDistance + weight; if (distanceThroughU < v.minDistance) { vertexQueue.remove(v);

v.minDistance = distanceThroughU ; v.previous = u;
vertexQueue.add(v);
}
}
}
}

public static List<Vertex> getShortestPathTo(Vertex target)
{
List<Vertex> path = new ArrayList<Vertex>();
for (Vertex vertex = target; vertex != null; vertex = vertex.previous) path.add(vertex);

Collections.reverse(path); return path;
}

public static void main(String[] args)
{
// mark all the vertices Vertex A = new Vertex("A"); Vertex B = new Vertex("B"); Vertex D = new Vertex("D"); Vertex F = new Vertex("F"); Vertex K = new Vertex("K"); Vertex J = new Vertex("J");
 
Vertex M = new Vertex("M"); Vertex O = new Vertex("O"); Vertex P = new Vertex("P"); Vertex R = new Vertex("R"); Vertex Z = new Vertex("Z");

// set the edges and weight
A.adjacencies = new Edge[]{ new Edge(M, 8) }; B.adjacencies = new Edge[]{ new Edge(D, 11) }; D.adjacencies = new Edge[]{ new Edge(B, 11) }; F.adjacencies = new Edge[]{ new Edge(K, 23) }; K.adjacencies = new Edge[]{ new Edge(O, 40) }; J.adjacencies = new Edge[]{ new Edge(K, 25) }; M.adjacencies = new Edge[]{ new Edge(R, 8) }; O.adjacencies = new Edge[]{ new Edge(K, 40) }; P.adjacencies = new Edge[]{ new Edge(Z, 18) }; R.adjacencies = new Edge[]{ new Edge(P, 15) }; Z.adjacencies = new Edge[]{ new Edge(P, 18) };


computePaths(A); // run Dijkstra System.out.println("Distance to " + Z + ": " + Z.minDistance); List<Vertex> path = getShortestPathTo(Z); System.out.println("Path: " + path);
}
}

Output:

Distance to Z: 49.0 Path: [A, M, R, P, Z]





13.Write a java program to implement Dynamic Programming algorithm for 0/1 Knapsack Problem.
Source Code :
import java.util.Scanner;

public class Knapsack_DP
{
static int max(int a, int b)
{
return (a > b)? a : b;
}
static int knapSack(int W, int wt[], int val[], int n)
{
int i, w;
int [][]K = new int[n+1][W+1];

// Build table K[][] in bottom up manner
for (i = 0; i <= n; i++)
{
for (w = 0; w <= W; w++)
{
if (i==0 || w==0) K[i][w] = 0;
else if (wt[i-1] <= w)
K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]); else
K[i][w] = K[i-1][w];
}
}

return K[n][W];
}

public static void main(String args[])
{
 
Scanner sc = new Scanner(System.in); System.out.println("Enter the number of items: "); int n = sc.nextInt();
System.out.println("Enter the items weights: ");
int []wt = new int[n]; for(int i=0; i<n; i++) wt[i] = sc.nextInt();

System.out.println("Enter the items values: ");
int []val = new int[n]; for(int i=0; i<n; i++)
val[i] = sc.nextInt();

System.out.println("Enter the maximum capacity: ");
int W = sc.nextInt();

System.out.println("The maximum value that can be put in a knapsack of capacity W is: " + knapSack(W, wt, val, n));
sc.close();
}
}

Output:
$ javac Knapsack_DP.java
$ java Knapsack_DP

Enter the number of items:
5
Enter the items weights:
01 56 42 78 12
Enter the items values:
50 30 20 10 50
Enter the maximum capacity:
150
The maximum value that can be put in a knapsack of capacity W is: 150
    
</code>
</pre>

</body>
</html>
